<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Angelo的代码工坊</title>
  
  <subtitle>I shut my eyes in order to see.</subtitle>
  <link href="https://values.keys.moe/atom.xml" rel="self"/>
  
  <link href="https://values.keys.moe/"/>
  <updated>2022-09-28T07:38:38.409Z</updated>
  <id>https://values.keys.moe/</id>
  
  <author>
    <name>Angelo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Delving into Data: Effectively Substitute Training for Black-box Attack</title>
    <link href="https://values.keys.moe/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/"/>
    <id>https://values.keys.moe/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/</id>
    <published>2021-12-07T10:06:33.000Z</published>
    <updated>2022-09-28T07:38:38.409Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/封面.png" alt><h1><span id="深入研究数据用于黑盒攻击的有效替代训练">深入研究数据：用于黑盒攻击的有效替代训练</span></h1><h2><span id="摘要">摘要</span></h2><p>​深度模型在处理对抗样本时显示了它们的脆弱性。对于黑盒攻击，在无法访问被攻击模型的架构和权重的情况下，大家广泛聚焦于训练对抗攻击的替代模型的方法。以往的替代训练方法主要是基于真实训练数据或合成数据来窃取目标模型的知识，而没有探索什么样的数据可以进一步提高替代模型和目标模型之间的可转移性。本文中，我们提出了一种新视角的替代训练，聚焦于设计知识窃取过程中使用的数据分布。更具体地说，我们提出了一个多样化数据生成模块来合成具有广泛分布的大规模数据。我们还引入了对抗替代训练策略，以关注分布在决策边界附近的数据。这两个模块的结合可以进一步提高替代模型和目标模型的一致性，从而大大提高了对抗攻击的有效性。大量的实验证明了我们的方法在非定向和定向攻击设置下对最先进的竞争对手的有效性。我们还提供了详细的可视化和分析，以帮助理解我们方法的优势。</p><span id="more"></span><h2><span id="1-介绍">1. 介绍</span></h2><p>​尽管在大多数计算机视觉任务中取得了优异的性能，但深度神经网络（DNN）已被证明容易受到难以察觉的对抗噪声或扰动的影响。对抗样本的存在揭示了将DNN部署到现实世界应用中的重要安全风险。当前社区以白盒与黑盒的设置之分来研究对抗攻击（它们的差异在于是否能完全访问目标攻击模型）。事实上，由于白盒攻击所需的完整目标模型信息在现实世界的部署中是不可用的，本文聚焦于黑盒攻击，其通常只基于目标模型的标签或输出分数来生成对抗样本。通常，黑盒攻击包括基于分数的方法或基于决策的方法。然而，在这些攻击中，需要对目标模型进行雪崩式查询，这仍可能限制它们在现实情况下攻击DNN的可用性。<br>​最近，替代训练的想法在黑盒攻击中得到了广泛的探索。通常情况下，该方法并不是直接生成对抗样本，而是训练一个替代模型，在相同的输入数据的查询下，做出与目标模型类似的预测。在一定数量的查询下，这种方法通常能够根据目标模型学习到替代模型。因此可以对替代模型进行攻击，然后可以转移到目标模型上。<br>​从根本上说，替代模型试图通过给出输入数据和相应的查询标签来从目标模型中获取知识。而关键问题是，输入数据是否来自目标模型的训练数据？假设“是”的话，它确实简化了替代训练。然而，在许多现实世界的视觉任务中，收集真实的输入数据甚至是非平凡的。例如，人物照片和视频的数据受到非常严格的控制，个人数据的隐私在很多国家都受到法律的保护。此外，真实图像是最有效的替代训练数据吗？目标模型的训练数据确实有助于在原始任务上得到一个表现良好的替代模型，但其不能保证攻击从替代模型到目标模型的可转移性。为了提高替代训练中的攻击性能，有必要使替代模型和目标模型之间的决策边界距离最小化，这不仅需要大规模和多样化的训练数据，而且特别需要分布在决策边界附近的数据。</p><p>​为了解决真实数据的局限性并探索替代训练数据的更好分布，我们提出了一种新颖的任务驱动统一框架，该框架仅使用专门设计的生成数据进行替代训练，并实现了高攻击性能。如图所示，与使用目标模型的训练数据进行替代训练相比，多样化的合成数据与对抗样本相结合，将促进替代模型进一步接近目标。更具体地说，在我们的框架中，我们首先提出了一个新颖的多样化数据生成模块（Data Generation module, DDG），该模块将噪声采样与标签嵌入信息相结合来生成多样化的训练数据。这样的分布式生成数据基本可以保证替代模型从目标中学习知识。此外，为进一步促使替代模型具有与目标相似的决策边界，我们提出了对抗替代训练策略（Adversarial Substitute Training strategy, AST），其将对抗样本作为边界数据引入训练过程。总的来说，DDG和AST的联合学习保证了替代模型和目标模型之间的一致性，这大大提高了在没有任何真实数据的情况下进行黑盒攻击的替代训练的成功率。</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/图1.png" alt><p>图1 将真实数据和合成数据应用于替代训练之间的差异。T&#x2F;S表示目标&#x2F;替代模型，(b)中的蓝色+&#x2F;-表示对抗样本，绿色&#x2F;红色虚线表示决策边界。比较(a)和(b)可以得到，我们的方法生成的合成数据可以训练一个与目标模型具有更相似决策边界的替代模型。</p><p>​本工作的主要贡献总结为：（1）我们首次提出了一种新的基于有效生成的替代训练范式，其通过深入研究输入生成的替代训练数据的本质，来提高无数据黑盒攻击的性能。（2）为了实现这一目标，我们首先提出了一个具有多种不同约束的多样化数据生成模块，以扩大合成数据的分布。然后通过对抗替代训练策略进一步提高替代模型和目标模型之间决策边界的一致性。（3）对四个数据集和一个在线机器学习平台的综合实验和可视化证明了我们的方法相对最先进攻击的有效性。</p><h2><span id="2-方法">2. 方法</span></h2><h3><span id="21-框架概述">2.1. 框架概述</span></h3><p>​我们工作的目标是为黑盒对抗攻击有效地训练替代模型，提出的框架如图所示。它由两个模块组成。多样化数据生成模块（DDG）产生多样化的数据，对抗替代训练策略（AST）进一步模仿目标模型的“行为”。在(a)中，DDG根据随机噪声z(i）和标签索引i的标签嵌入向量e(i)生成数据<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式1.png" alt>。为了保证合成数据的多样性，生成器G通过三个约束进行训练，即自适应标签归一化生成器、噪声&#x2F;标签重建和类间多样性，这将在后面详细说明。此外，为了确保替代模型S接近目标模型T的决策边界，我们将合成的数据和AST的对抗样本一起输入S以进行(b)中的替代训练。从本质上讲，我们把目标模型T作为分类为M类的黑盒，其中只有标签&#x2F;概率输出可用。师生策略在这里被用于从T学习到S。最后，攻击可以在替代模型上进行，然后转移到目标模型上。</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/图2.png" alt><p>​图2 整体框架图示。其由多样化数据生成模块（DDG）和对抗替代训练模块（AST）组成。（a）DDG旨在生成具有给定标签的不同数据以训练替代模型。（b）AST利用从当前替代模型生成的对抗样本来推动替代模型模仿目标的边界。</p><h3><span id="22-多样化数据生成">2.2. 多样化数据生成</span></h3><p>​为了合成更好的数据用于替代训练，我们首先提出了一个新颖的多样性数据生成模块（DDG），该模块有三个约束条件来操纵生成的合成图像的多样性。这些约束条件原则上鼓励生成器G为每个不同的类学习相对独立的数据分布，并保持类间差异，从而促进替代模型学习目标模型的知识。</p><p>​<strong>自适应标签归一化生成器</strong>。为了更好地从目标模型中学习，我们需要所有类别的平均分布数据进行替代训练，因此有必要生成标签控制的数据。为了实现这一点，我们充分利用了给定的标签和随机噪声。首先，通过从标准高斯分布和标签i中采样的随机噪声向量<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式2.png" alt>的输入，我们计算出基于嵌入层的标签嵌入向量<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式3.png" alt>。这种标签嵌入过程可以将单个离散标签编码为一个连续的可学习向量，它在特征空间中的分布更广，包含更多的表示信息。与GAN不同，我们没有使用真实的图像进行监督，这样的标签嵌入过程对数据的生成至关重要。接下来，我们通过两个全连接层从N维标签嵌入向量e(i)中提取平均值μ(i)和方差σ(i)。之后，将μ(i)和σ(i)加入到所有的反卷积块中，迭代合成具有特定类别条件的图像数据，可以表示为：</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式4.png" alt><p>其中总共有五个反卷积块，t表示反卷积块的数量。在获得最终的ˆx(i)之后，输出生成的数据已经被标签归一化的信息进行了修改。这种自适应标签归一化生成器可以更好地利用输入噪声和标签嵌入向量之间的关系来合成标签控制的数据。</p><p><strong>噪声&#x2F;标签重建</strong>。为了进一步确保生成数据ˆx (i)的多样性，我们引入了一个重建网络R来重建输入噪声和标签嵌入<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式5.png" alt>。而相应的重建损失可以计算为</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式6.png" alt><p>其中我们使用L1来表示输入z(i)和重建的z(i)r之间的差异。对于标签重建，我们应用函数f(∗)来计算e(i)r和e之间的余弦距离，并由Softmax进一步处理以计算与真实标签i的交叉熵损失。在这种约束下，G可以为每个类别的不同输入噪声向量生成更多样的图像。</p><p><strong>类间多样性</strong>。为了进一步增强不同类别的数据多样性，我们使用余弦相似矩阵来最大化所有合成图像的类间距离。特别地，生成器生成一个MB≪M的不同类别的输入合成数据batch，模型S给出这个batch的输出相似度矩阵<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式7.png" alt>。请注意，我们有真实的相似性矩阵<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式8.png" alt>，除了对角线元素被设置为1，其他元素都是0。因此，多样性损失函数Ldiv可以表述为：</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式9.png" alt><p>其中，TRI(∗)被定义为提取相似度矩阵中除对角线元素外的上三角元素的操作。通过这种方式，Ldiv确保合成数据拥有每个类别的独立分布。</p><h3><span id="23-对抗替代训练">2.3. 对抗替代训练</span></h3><p>​在DDG生成多样化的训练数据后，为了获得更好的攻击性能，我们还需要进一步鼓励与目标决策边界更相似的替代模型。众所周知，对抗样本拥有视觉上难以区分的扰动，其会被模型错误的分类。由于扰动相对较小，对抗样本可以看作是决策边界周围的样本。因此，我们提出了一种新颖的对抗替代训练策略（AST），它利用对抗样本进一步推动S的决策边界与T的决策边界相似。更具体地说，对于训练期间的每次迭代，我们的生成器首先通过DDG合成图像。然后我们选择白盒攻击算法来获得基于当前S的合成图像的对抗扰动ε。生成对抗图像的目标函数定义为</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式10.png" alt><p>其中L(·) 表示攻击目标，反映了预测xˆ(i)+ε的标签为iadv的概率或交叉熵。如果考虑非定向攻击，则iadv≠i，否则iadv&#x3D;t，t为目标标签。λ是正则化系数，约束ε∈[0, 1]d将扰动ε限制在有效图像空间内。然后，生成的图像和相应的对抗数据被用来一起更新S。</p><h3><span id="24-损失函数">2.4. 损失函数</span></h3><p>​最后，我们应用基本损失函数来训练替代模型</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式11.png" alt><p>其中Ld测量T和S输出之间的距离，Lc表示生成损失。e-Ld表示Ld的“最小-最大”博弈，CE(·)表示S的预测和输入的真实标签i之间的交叉熵损失。因此，凭借这两个损失函数的交替最小化，替代模型S可以学习模仿目标模型T的输出。在DDG和AST的进一步推动下，通过生成的数据和对抗样本，用于训练S和G的统一替代训练损失LS和生成器损失LG被定义为</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/公式12.png" alt><p>其中Ladvd的定义与等式中的Ld相同。之前的公式使用对抗样本作为输入测量T和S的输出间的距离，Ladvc被定义为Lc，以约束以对抗样本作为输入的生成，Lrec和Ldiv被用来增强数据多样性。β1、β2和β3是DDG的平衡超参数。总的来说，训练过程如下。</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/算法1.png" alt><h2><span id="3-实验">3. 实验</span></h2><h3><span id="31-实验设置">3.1. 实验设置</span></h3><p>​<strong>数据集和目标模型</strong>。1) MNIST：攻击模型在AlexNet、VGG-16和ResNet-18上进行预训练。默认的替代模型是具有3个卷积层的网络。2)CIFAR-10：攻击者在AlexNet、VGG-16和 ResNet-18上进行了预训练。默认替代模型是VGG-13。3) CIFAR-100：被攻击者在VGG-19和ResNet50上进行了预训练。默认的替代模型是ResNet-18。4)Tiny Imagenet：被攻击者在ResNet-50上进行了预训练。替代模型是ResNet-34。<br>​<strong>比较对象</strong>。为了验证所提出方法的有效性，我们将我们的攻击结果与无数据黑盒攻击（如DaST）和几种需要真实数据的黑盒攻击（如PBBA和Knockoff）。我们还使用被攻击模型的原始训练数据进行替代训练，并利用ImageNet学习替代模型。<br>​<strong>实现细节</strong>。我们使用Pytorch进行实现。我们利用Adam从头开始训练我们的替代模型、生成器和重建网络，所有权重都使用标准差为0.02的截断正态分布随机初始化。所有网络的初始学习率均设置为0.0001，从第80个epoch开始逐渐降低到0，并在第150个epoch后停止。我们将mini-batch大小设置为500，超参数β1、β2和β3值为1。我们的模型由一个 NVIDIA GeForce GTX 1080Ti GPU训练。我们应用PGD作为在AST和评估期间生成对抗图像的默认方法。我们还使用FGSM、BIM和C&amp;W进行广泛实验的攻击。<br>​<strong>评价指标</strong>。 考虑到 DaST中提出的存在两种不同的场景，即只从目标模型中获取输出标签并很好地访问输出概率，我们将这两种场景命名为基于概率和基于标签。在实验中，我们报告了由替代模型产生的对抗样本攻击目标黑盒模型的攻击成功率（ASRs）。按照DaST的设置，在非目标攻击设置中，我们只在被攻击模型正确分类的图像上生成对抗样本。对于目标攻击，我们只在没有被分类到特定错误标签的图像上生成对抗样本。为了公平比较，在所有的对抗样本过程中，设定扰动ε&#x3D;8。我们对每个测试进行五次，并报告平均结果。</p><h3><span id="32-黑盒攻击结果">3.2. 黑盒攻击结果</span></h3><p>​我们与比较对象手在四个数据集和一个在线机器学习平台上评估我们的方法，包括了定向攻击和非定向攻击设置。如表1、2、3所示，我们在基于概率和基于标签的场景下对每个数据集的多个目标模型进行了广泛的比较。</p><img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/表1.png" alt>表1 使用概率作为我们的方法和比较对象在多个数据集上的目标模型输出来比较ASRs结果<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/表2.png" alt>表2 使用标签作为我们的方法和比较对象在多个数据集上的目标模型输出来比较ASRs结果<img src="/2021/12/07/Delving%20into%20Data%20Effectively%20Substitute%20Training%20for%20Black-box%20Attack/表3.png" alt>表3 比较攻击Microsoft Azure示例模型下我们的方法和比较对象的ASRs结果<p>​<strong>与真实数据进行替代训练进行比较</strong>。这里我们研究了用真实图像进行攻击的替代训练，如表1和表2所示。我们直接使用目标模型或ImageNet的原始训练数据进行替代训练，而不是合成训练。结果显示，真实图像可以让替代模型从目标中学习到部分东西，在分类上可能会有更高的准确率，但与生成的数据相比，攻击强度较弱。我们认为，这个问题是由真实图像的数量和多样性限制造成的，这可能导致替代模型学习和模仿目标模型的失败。因此，我们提出了一种DDG策略来合成大规模和多样化的数据。<br>​<strong>与最新方法的比较</strong>。如表1和表2所示，我们将我们的方法与黑盒攻击进行比较。对于定向攻击和非定向攻击，我们的方法在所有数据集下都取得了比基于概率和基于标签的方案更好的ASRs。此外，与相似的生成法DaST相比，我们的方法很大程度上优于它。这些结果验证了所提出的方法让替代模型更好地接近目标的决策边界和实现无数据黑盒攻击的高ASRs这两个方面的有效性。<br>​<strong>在Microsoft Azure上与比较对象的比较</strong>。为了更好地评估实际应用下的攻击手段能力，我们在Microsoft Azure上进行了在线模型攻击实验。通过以攻击Azure上机器学习教程中的MNIST模型为目标，我们比较了我们的方法和竞争对手之间的结果。表3中显示的结果表明了我们的方法可以在在线模型上获得最好的ASR，这进一步证明了我们的方法在没有攻击先验知识的真实场景下的有效性。</p><h2><span id="4-结论">4. 结论</span></h2><p>​本文重点研究黑盒攻击替代训练的生成数据的分布。它提出了一个统一的替代模型训练框架，包含一个多样化数据生成模块（DDG）和一个对抗替代训练策略（AST）。DDG可以生成标签控制的和多样化的数据来训练替代模型。AST利用对抗样本作为边界数据，使替代模型更好地符合目标的决策边界。大量实验表明该方法可以实现高攻击性能。</p>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="论文阅读" scheme="https://values.keys.moe/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="论文阅读" scheme="https://values.keys.moe/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>新的故事与旧的回忆 —— 2017~2021 我的本科四年</title>
    <link href="https://values.keys.moe/2021/06/21/%E6%96%B0%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%8E%E6%97%A7%E7%9A%84%E5%9B%9E%E5%BF%86%20%E2%80%94%E2%80%94%202017~2021%20%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%9B%9B%E5%B9%B4/"/>
    <id>https://values.keys.moe/2021/06/21/%E6%96%B0%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%8E%E6%97%A7%E7%9A%84%E5%9B%9E%E5%BF%86%20%E2%80%94%E2%80%94%202017~2021%20%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%9B%9B%E5%B9%B4/</id>
    <published>2021-06-20T16:54:45.000Z</published>
    <updated>2022-09-28T06:55:23.539Z</updated>
    
    <content type="html"><![CDATA[<img src="/2021/06/21/%E6%96%B0%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%8E%E6%97%A7%E7%9A%84%E5%9B%9E%E5%BF%86%20%E2%80%94%E2%80%94%202017~2021%20%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%9B%9B%E5%B9%B4/新的故事与旧的回忆.jpg" alt><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/2021/06/21/%E6%96%B0%E7%9A%84%E6%95%85%E4%BA%8B%E4%B8%8E%E6%97%A7%E7%9A%84%E5%9B%9E%E5%BF%86%20%E2%80%94%E2%80%94%202017~2021%20%E6%88%91%E7%9A%84%E6%9C%AC%E7%A7%91%E5%9B%9B%E5%B9%B4/新的故事与旧的回忆.jpg&quot; alt&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://values.keys.moe/categories/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="杂谈" scheme="https://values.keys.moe/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>通过Xrdp实现Windows远程访问Ubuntu 16.04</title>
    <link href="https://values.keys.moe/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/"/>
    <id>https://values.keys.moe/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/</id>
    <published>2019-03-05T03:25:45.000Z</published>
    <updated>2022-09-28T06:24:41.208Z</updated>
    
    <content type="html"><![CDATA[<p>​目前网上的大量教程都是需要安装xfac4或者xubuntu桌面系统才能实现远程连接。因为xrdp支持在13.10之后版本就已经不支持的Gnome了和原生Unity桌面，所以网上很多方法都是安装能够被xdrp支持的第三方xfac4或者xubuntu桌面系统间接达到远程控制Ubuntu。<br>​本文提供如何使用Xrdp访问原生Ubuntu桌面。</p><span id="more"></span><h2><span id="step1-下载tigervnc-server软件包">Step.1 下载TigerVNC Server软件包</span></h2><p>下载地址：<br><a href="http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip">http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip</a></p><h2><span id="step2-安装tigervnc-server">Step.2 安装TigerVNC Server</span></h2><p>1.打开终端，进入到刚刚你你下载TigerVNC Server的存放目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> 下载</span><br></pre></td></tr></table></figure><p>2.执行安装指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i tigervncserver_1.<span class="number">6.80</span>-<span class="number">4</span>_amd64.<span class="keyword">deb</span></span><br><span class="line">或者</span><br><span class="line">sudo apt-<span class="built_in">get</span> install tightvncserver</span><br></pre></td></tr></table></figure><p>过程中如果出现警告信息和错误信息，原因是没有相对应的依赖包。<br>执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">f</span></span><br></pre></td></tr></table></figure><p>然后在执行之前的安装命令。</p><h2><span id="step3-安装xrdp">Step.3 安装Xrdp</span></h2><p>终端输入安装命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install xrdp -<span class="keyword">y</span></span><br></pre></td></tr></table></figure><h2><span id="step4-配置xrdp">Step.4 配置Xrdp</span></h2><p>需要通过xrdp连接到桌面，<br>需要正确配置相关信息并填充到.xsession文件（针对每个用户）<br>或&#x2F;etc&#x2F;startwm.sh（针对所有用户）<br>命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> unity&gt;~/.xsession</span><br><span class="line">或者</span><br><span class="line">sudo sed -i.bak <span class="string">&#x27;/fi/a #xrdp multi-users \n unity \n&#x27;</span> /etc/xrdp/startwm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h2><span id="step5-重启xrdp服务">Step.5 重启Xrdp服务</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure><h2><span id="step6-开启桌面共享功能">Step.6 开启桌面共享功能</span></h2><img src="/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/桌面共享.jpg" alt><p>系统-&gt;首选项-&gt;桌面共享，或者直接搜索桌面共享功能<br>进入后<br>将【允许其他人查看您的桌面】勾上，<br>【自动配置UPnP路由器开放和转发接口】勾上，如图所示</p><img src="/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/桌面共享2.jpg" alt><p>之后配置基本结束。Windows可以通过mstc直接通过IP访问Ubuntu。</p><hr><p>注：Ubuntu18尝试后似乎没有桌面共享功能的选项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​		目前网上的大量教程都是需要安装xfac4或者xubuntu桌面系统才能实现远程连接。因为xrdp支持在13.10之后版本就已经不支持的Gnome了和原生Unity桌面，所以网上很多方法都是安装能够被xdrp支持的第三方xfac4或者xubuntu桌面系统间接达到远程控制Ubuntu。&lt;br&gt;​		本文提供如何使用Xrdp访问原生Ubuntu桌面。&lt;/p&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://values.keys.moe/categories/Ubuntu/"/>
    
    
    <category term="Ubuntu" scheme="https://values.keys.moe/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>树莓派人脸识别-face-recognition的安装与应用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-02T03:06:57.000Z</published>
    <updated>2022-09-27T17:08:54.800Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/人脸识别.gif" alt><span id="more"></span><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/face_recongnition.png" alt>该库可以通过python或者命令行即可实现人脸识别的功能。使用dlib深度学习人脸识别技术构建，在户外脸部检测数据库基准（Labeled Faces in the Wild）上的准确率为99.38%。<h2><span id="安装过程"><strong>安装过程</strong></span></h2><p>先在终端下安装一大堆需要的库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span> sudo apt-<span class="built_in">get</span> install build-essential \</span><br><span class="line">cmake \</span><br><span class="line">gfortran \</span><br><span class="line">git \</span><br><span class="line">wget \</span><br><span class="line">curl \</span><br><span class="line">graphicsmagick \</span><br><span class="line">libgraphicsmagick1-dev \</span><br><span class="line">libatlas-dev \</span><br><span class="line">libavcodec-dev \</span><br><span class="line">libavformat-dev \</span><br><span class="line">libboost-<span class="keyword">all</span>-dev \</span><br><span class="line">libgtk2.<span class="number">0</span>-dev \</span><br><span class="line">libjpeg-dev \</span><br><span class="line">liblapack-dev \</span><br><span class="line">libswscale-dev \</span><br><span class="line">pkg-config \</span><br><span class="line"><span class="keyword">python3</span>-dev \</span><br><span class="line"><span class="keyword">python3</span>-numpy \</span><br><span class="line"><span class="keyword">python3</span>-pip \</span><br><span class="line">zip</span><br></pre></td></tr></table></figure><p>如果使用树莓派的摄像头（CSI接口），执行下面的命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">python3</span>-picamera</span><br><span class="line">sudo pip3 install --upgrade picamera[array]</span><br></pre></td></tr></table></figure><p>下载安装dlib：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> dlib </span><br><span class="line">git clone -<span class="keyword">b</span> <span class="string">&#x27;v19.6&#x27;</span> --single-branch https://github.<span class="keyword">com</span>/davisking/dlib.git dlib/ </span><br><span class="line"><span class="keyword">cd</span> ./dlib</span><br><span class="line">sudo <span class="keyword">python3</span> setup.<span class="keyword">py</span> install --<span class="keyword">compiler</span>-flags <span class="string">&quot;-mfpu=neon&quot;</span></span><br></pre></td></tr></table></figure><p>安装face_recognition：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install face_recognition</span><br></pre></td></tr></table></figure><p>下载示例代码并尝试运行（可选）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --single-branch https://github.<span class="keyword">com</span>/ageitgey/face_recognition.git</span><br><span class="line"><span class="keyword">cd</span> ./face_recognition/examples</span><br><span class="line"><span class="keyword">python3</span> facerec_on_raspberry_pi.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：过程缺少库时，使用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache <span class="built_in">search</span> 库名</span><br></pre></td></tr></table></figure><p>来搜索到那个库的安装包，然后用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install 包名</span><br></pre></td></tr></table></figure><p>来安装。</p><p><strong>例如</strong>：缺少了libatlas.so.3，那我们就用<strong>apt-cache search libatlas</strong>来搜索，发现它的包名叫libatlas3-base，所以我们用<strong>sudo apt-get install libatlas3-base</strong>来安装。<br>后面测试摄像头的时候也会遇到这样的问题，解决办法是一样的。 </p><p>待把CSI接口树莓派摄像头装上后，在raspi-config中启用摄像头，然后重启。<br>（详见博客内关于CSI摄像头的另一篇文章）</p><p>运行一下实时人脸识别的代码（可选）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> facerec_from_webcam_faster.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>过程可能报错，import cv2的时候缺少库，然后根据提示用之前安装方法安装就好了。装完一个库再运行的时候，发现又提示缺少别的库，然后再安装缺少的库。反复个多次，把缺少的库都装好即可。</p><p>再次运行的时候，会报别的错误，出错的代码是</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">small_frame = cv2.<span class="keyword">resize</span>(frame, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.25</span>, fy=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>这是因为video_capture.read()没有读到图片。<br>树莓派中的camera module是放在&#x2F;boot&#x2F;目录中以固件形式加载的，不是一个标准的V4L2的摄像头驱动，所以加载起来之后会找不到&#x2F;dev&#x2F;video0的设备节点。<br><strong>解决方法</strong>：转载<a href="https://blog.csdn.net/deiki/article/details/71123947">https://blog.csdn.net/deiki/article/details/71123947</a></p><p>之后可以使用下面的命令来加载驱动模块：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>如果想开机自动加载，我们可以修改&#x2F;etc&#x2F;modules文件，添加一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>如下图所示：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/bcm2835-v4l2.png" alt></p><p>安装过程基本完毕。</p><h2><span id="个人提供的样例代码"><strong>个人提供的样例代码：</strong></span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env </span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#从目录中读取一堆文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> RPi.GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">RPi.GPIO.setmode(RPi.GPIO.BCM)</span><br><span class="line"></span><br><span class="line">RPi.GPIO.setwarnings(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">buzzer=<span class="number">4</span></span><br><span class="line">RPi.GPIO.setup(buzzer,RPi.GPIO.OUT)</span><br><span class="line"></span><br><span class="line">RPi.GPIO.output(buzzer,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">strangerAppear=<span class="literal">False</span></span><br><span class="line">strangerNum=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo_filelist=[]</span><br><span class="line">demo_face_encodings=[]</span><br><span class="line">demo_face_names=[]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&#x27;/home/pi/demo/face_recognition/jpg//&#x27;</span>):</span><br><span class="line">    demo_filelist.append(f)</span><br><span class="line">    demo_face_names.append(f[:-<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> demo_filelist:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">u&#x27;正在加载....&#x27;</span>+filename)</span><br><span class="line">    demo_image = face_recognition.load_image_file(<span class="string">&#x27;/home/pi/demo/face_recognition/jpg//&#x27;</span>+filename)</span><br><span class="line">    face_encoding = face_recognition.face_encodings(demo_image)[<span class="number">0</span>]</span><br><span class="line">    demo_face_encodings.append(face_encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize some variables</span></span><br><span class="line">face_locations = []</span><br><span class="line">face_encodings = []</span><br><span class="line">face_names = []</span><br><span class="line">process_this_frame = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get a reference to webcam #0 (the default one)</span></span><br><span class="line">video_capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Grab a single frame of video</span></span><br><span class="line">    ret, frame = video_capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Resize frame of video to 1/4 size for faster face recognition processing</span></span><br><span class="line">    small_frame = cv2.resize(frame, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.3</span>, fy=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Only process every other frame of video to save time</span></span><br><span class="line">    <span class="keyword">if</span> process_this_frame==<span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Find all the faces and face encodings in the current frame of video</span></span><br><span class="line">        face_locations = face_recognition.face_locations(small_frame)</span><br><span class="line">        face_encodings = face_recognition.face_encodings(small_frame, face_locations)</span><br><span class="line">   <span class="comment">#     print(u&quot;我检测到了&#123;&#125;张脸。&quot;.format(len(face_locations)))</span></span><br><span class="line">        face_names = []</span><br><span class="line">        <span class="keyword">for</span> face_encoding <span class="keyword">in</span> face_encodings:</span><br><span class="line">        <span class="comment"># See if the face is a match for the known face(s)</span></span><br><span class="line">            <span class="keyword">match</span> = face_recognition.compare_faces(demo_face_encodings, face_encoding,tolerance=<span class="number">0.6</span>)<span class="comment">#</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">match</span>)</span><br><span class="line">            name = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">            i=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="keyword">match</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m:</span><br><span class="line">                    name= demo_face_names[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(name==<span class="string">&quot;Unknown&quot;</span>):</span><br><span class="line">                RPi.GPIO.output(buzzer,<span class="literal">False</span>)</span><br><span class="line">                frame_1=cv2.flip(frame,<span class="number">1</span>)</span><br><span class="line">                path=<span class="string">&quot;/home/pi/demo/face_recognition/&quot;</span>+<span class="built_in">str</span>(strangerNum)+<span class="string">&quot;.png&quot;</span></span><br><span class="line">                cv2.imwrite(path,frame_1)</span><br><span class="line">                strangerNum=strangerNum+<span class="number">1</span></span><br><span class="line">                strangerAppear=<span class="literal">True</span></span><br><span class="line">            face_names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display the results</span></span><br><span class="line">    <span class="keyword">for</span> (top, right, bottom, left), name <span class="keyword">in</span> <span class="built_in">zip</span>(face_locations, face_names):</span><br><span class="line">        <span class="comment"># Draw a box around the face</span></span><br><span class="line">        <span class="comment">#cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw a label with a name below the face</span></span><br><span class="line"><span class="comment">#        cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), 5)</span></span><br><span class="line">        font = cv2.FONT_HERSHEY_DUPLEX<span class="comment">#FONT_HERSHEY_DUPLEX</span></span><br><span class="line"><span class="comment">#        print(name)</span></span><br><span class="line"><span class="comment">#        boxsize, _ = cv2.getTextSize(fs.string, fs.face, fs.fsize, fs.thick)</span></span><br><span class="line"> <span class="comment">#       locx = int((right+left)/2-25 - 14*len(name)/2)</span></span><br><span class="line">        cv2.putText(frame, name, (<span class="number">20</span>,<span class="number">20</span>), font, <span class="number">1.0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    process_this_frame += <span class="number">1</span><span class="comment"># not process_this_frame</span></span><br><span class="line">    <span class="keyword">if</span> process_this_frame&gt;<span class="number">1</span>:</span><br><span class="line">        process_this_frame=<span class="number">1</span></span><br><span class="line">    <span class="comment"># Display the resulting image</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Video&#x27;</span>, frame)</span><br><span class="line">    cv2.moveWindow(<span class="string">&#x27;Video&#x27;</span>,<span class="number">600</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hit &#x27;q&#x27; on the keyboard to quit!</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        RPi.GPIO.output(buzzer,<span class="literal">True</span>)</span><br><span class="line">        strangerAppear=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Release handle to the webcam</span></span><br><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派CSI摄像头的连接与常用指令</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-03-02T01:28:19.000Z</published>
    <updated>2022-09-28T06:03:44.256Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/CSI摄像头.jpg" alt><span id="more"></span><h1><span id="安装树莓派摄像头模块">安装树莓派摄像头模块</span></h1><p>​1、找到 CSI 接口(CSI接口在以太网接口旁边)，掀起深色胶带。<br>​2、拉起 CSI 接口挡板。<br>​3、拿起你的摄像头模块，将贴在镜头上的塑料保护膜撕掉。确保黄色部分的PCB(有字的一面)是安装完美的（可以轻轻按一下黄色的部分来保证安装完美）。<br>​4、将排线插入CSI接口。记住，有蓝色胶带的一面应该面向以太网接口方向。同样，这时也确认一下排线安装好了之后，将挡板拉下。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/安装图.jpg" alt><h1><span id="在树莓派上启用摄像头模块">在树莓派上启用摄像头模块</span></h1><p>在安装完摄像头模块之后，首先要确认你已经升级了树莓派系统并应用了最新的固件。<br>终端下可以输入以下命令来操作：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span>   </span><br><span class="line">sudo apt-<span class="built_in">get</span> upgrade </span><br></pre></td></tr></table></figure><p>运行树莓派配置工具来激活摄像头模块：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>移动光标至菜单中的 “Enable Camera（启用摄像头）”，将其设为Enable（启用状态）。完成之后重启树莓派。</p><h1><span id="安装驱动使能树莓派的相关模块">安装驱动使能树莓派的相关模块</span></h1><h2><span id="1-添加驱动程序文件进来">1、添加驱动程序文件进来：</span></h2><p>终端输入指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/modules</span><br></pre></td></tr></table></figure><p>在最后添加如下的代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>这样就完成了在启动过程中加载camera驱动的前提。</p><h2><span id="2-修改raspberry的启动配置使能项">2、修改Raspberry的启动配置使能项：</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure> <img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/配置1.jpg" alt><p>(由于系统版本，树莓派版本不同，显示设置可能不同，但基本大同小异。)<br>选择Interfacing Option，选中Select然后Enter进入，如下图所示： </p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/配置2.jpg" alt><h2><span id="3-检查x2fdev下面是否存在摄像头设备">3、检查&#x2F;dev下面是否存在摄像头设备</span></h2><p>重启完之后，我们的基本的操作就完成了，下来来看看&#x2F;dev下面是否存在摄像头设备的问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /dev/ | grep video</span><br></pre></td></tr></table></figure><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/检查.jpg" alt><h1><span id="使用操作树莓派的摄像头">使用操作树莓派的摄像头</span></h1><p>下面简单的使用操作树莓派的摄像头：<br>1、我们使用rapistill指令来截图</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspistill -<span class="keyword">o</span> image.jpg</span><br></pre></td></tr></table></figure><p>raspistill命令的相关参数和实验的具体效果：<br>-v：调试信息查看<br>-w：图像宽度<br>-h：图像高度<br>-rot：图像旋转角度，只支持 0、90、180、270 度（这里说明一下，测试发现其他角度的输入都会被转换到这四个角度之上）<br>-o：图像输出地址，例如image.jpg，如果文件名为“-”，将输出发送至标准输出设备<br>-t：获取图像前等待时间，默认为5000，即5秒<br>-tl：多久执行一次图像抓取<br>使用raspivid指令来生成.h246的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspivid -<span class="keyword">o</span> mykeychain.h264 -t <span class="number">10000</span> -<span class="keyword">w</span> <span class="number">1280</span> -h <span class="number">720</span> </span><br></pre></td></tr></table></figure><p>如果你想改变拍摄时长，只要通过 “-t” 选项来设置你想要的长度就行了（单位是毫秒）。<br>如果你想改变图像的分辨率，使用 “-w” 和 “-h” 选项将分辨率降为 1280x720等等。</p>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派常见问题与解决方案</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-03-02T01:26:05.000Z</published>
    <updated>2022-09-28T06:28:27.634Z</updated>
    
    <content type="html"><![CDATA[<p>又是老问题？（笑</p><span id="more"></span><h1><span id="树莓派有密码的网络联网失败的问题与解决">树莓派有密码的网络联网失败的问题与解决</span></h1><p><strong>在保证系统无任何修改的情况下：</strong><br>树莓派出现无法连接有密码的网络，而可以连接无密码网络的情况。<br>问题出现原因：<strong>电池电源电流供应不足</strong>。<br>解决方案：给树莓派micrioUSB处通以<strong>正常电源</strong>，问题得以解决。</p><h1><span id="修改树莓派热点的名称和密码">修改树莓派热点的名称和密码</span></h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/hostapd/hostapd.<span class="keyword">conf</span> </span><br></pre></td></tr></table></figure><p>其中ssid为热点的名称、wpa_passphrase为热点的密码<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/修改树莓派热点的名称和密码.jpg" alt></p><h1><span id="树莓派更换国内可用镜像源">树莓派更换国内可用镜像源</span></h1><p>***最新系统不用折腾换源了，亲测官方源可以使用。</p><p><strong>查看树莓派的镜像列表</strong><br><a href="http://www.raspbian.org/RaspbianMirrors">http://www.raspbian.org/RaspbianMirrors</a><br>操作</p><h2><span id="1-编辑sourceslist">1. 编辑sources.list</span></h2><p>打开终端 输入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>用#注释或直接删除原有的内容，新增两条：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">#deb-src http://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure><p>ctrl+x 保存并退出。</p><h2><span id="2-编辑raspilist">2. 编辑raspi.list</span></h2><p>sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list<br>用#注释或直接删除原有的内容，新增两条：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirror.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspberrypi/ stretch main ui</span><br><span class="line">#deb-src http://mirror.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspberrypi/ stretch main ui</span><br></pre></td></tr></table></figure><p>ctrl+x 保存并退出。</p><h2><span id="3-更新软件源列表">3. 更新软件源列表</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是老问题？（笑&lt;/p&gt;</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派空气质量检测仪-攀藤G5003ST的连接与使用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2019-03-02T01:23:34.000Z</published>
    <updated>2022-09-28T05:44:45.667Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/5003ST正.jpg" alt><span id="more"></span><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/5003ST反.jpg" alt><h1><span id="攀藤g5003st数字接口定义">攀藤G5003ST数字接口定义</span></h1><p><strong>pin1(VCC)</strong>:连接电压为3.3V&#x2F;5V电压<br><strong>pin2(GND)</strong> 电源-<br>**pin3(SET待机位置)**，设置管脚?&#x2F;TTL电平@3.3V，高电平或悬空为正常工作状态，低电平为休眠状态，该引脚可悬空。<br><strong>pin4(RXD串口接收管脚)</strong> 传感器接收来自树莓派的信号数据，如果不需要可以悬空<br><strong>pin5(TXD串口发送管脚)</strong> 传感器将信号发送给树莓派<br><strong>pin6(RESET)</strong> 模块复位信号&#x2F;TTL电平@3.3V，低复位，如果不需要使用可以悬空<br><strong>pin7(NC)</strong> : No internal connection. 无内部连接，不需连接。<br><strong>Pin8(NC&#x2F;PWM)</strong> : PWM周期为1s，其中低电平对应大气环境下的PM2.5质量浓度数据，每1ms低电平代表1ug&#x2F;m?。例如低电平时间长度为210ms，则代表此时PM2.5质量浓度值（大气环境）为210ug&#x2F;m?<br><strong>（pin7和pin8为程序内部调试使用，应用电路中应该使其悬空）</strong></p><p>树莓派Pi3的UART（ttyAMA0）是被蓝牙默认占用的，更改起来十分困难，在实体机上尝试多次无果后决定使用USB TO TTL转接口，直接将PMS5003ST接至树莓派的USB接口上，这样可以直接在&#x2F;dev&#x2F;tty中直接检索到USB0，即为传感器。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/接线.jpg" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/接线2.jpg" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/pin口.png" alt><h1><span id="攀藤g5003st技术指标">攀藤G5003ST技术指标</span></h1><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标1.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标2.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标3.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标4.png" alt><h1><span id="攀藤g5003st输出结果分析">攀藤G5003ST输出结果分析</span></h1><p>1.颗粒物浓度：主要输出为单位体积内各浓度颗粒物质量以及个数，其中颗粒物个数的单位体积为0.1升，质量浓度单位为：微克&#x2F;立方米（μg&#x2F;m3）。<br>此外传感器输出分为主动输出和被动输出两种状态。<br>传感器上电后默认状态为主动输出，即传感器主动向主机发送串行数据，时间间隔为200 ~ 800ms，空气中颗粒物浓度越高，时间间隔越短。<br>主动输出又分为两种模式：平稳模式和快速模式。<br>在空气中颗粒物浓度变化较小时，传感器输出为平稳模式，即每三次输出同样的一组数值，实际数据更新周期约为2s。<br>当空气中颗粒物浓度变化较大时，传感器输出自动切换为快速模式，每次输出都是新的数值，实际数据更新周期为200~800ms。<br>PWM输出：PMS3XXXP系列产品带有PWM输出，PWM周期为1秒，低电平时间长度代表PM2.5浓度（大气环境下），每1ms低电平代表1ug&#x2F;m3。<br>例如：低电平时间长度为210ms，则代表此时PM2.5质量浓度值（大气环境）为210ug&#x2F;m3<br>2.甲醛浓度输出：单位体积内甲醛质量浓度，单位为毫克&#x2F;立方米<br>3.温湿度输出：输出吸入传感器内部的采样空气温度及湿度。</p><h1><span id="攀藤g5003st对外输出格式">攀藤G5003ST对外输出格式</span></h1><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式0.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式1.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式2.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式3.png" alt><h1><span id="python程序实现">python程序实现</span></h1><p>读取数据：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/读取数据.png" alt></p><p>分析数据：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/分析数据.png" alt></p><p>得出数据结论：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/数据结论.png" alt></p>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用lirc红外控制树莓派</title>
    <link href="https://values.keys.moe/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>https://values.keys.moe/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/</id>
    <published>2019-03-02T01:20:33.000Z</published>
    <updated>2022-09-28T06:09:54.964Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/红外传感器.png" alt><span id="more"></span><p>红外传感器<br>引脚从上到下分别为<br>IO GND VCC</p><h1><span id="lirc的安装与使用">lirc的安装与使用</span></h1><p>使用红外，首先需要安装树莓派的lirc模块<br>LIRC (Linux Infrared remote control)是一个linux系统下开源的软件包。这个软件可以让Linux系统接收及发送红外线信号。<br>注意事项：<br><strong>安装：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install lirc</span><br></pre></td></tr></table></figure><p>修改以下几处：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo leafpad /etc/lirc/hardware.<span class="keyword">conf</span></span><br><span class="line">LIRCD_ATGS=<span class="string">&quot;&quot;</span></span><br><span class="line">DRIVER=<span class="string">&quot;default&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;/dev/lirc0&quot;</span></span><br><span class="line">MODULES=<span class="comment">&quot;lirc-rpi</span></span><br></pre></td></tr></table></figure><p>终端执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo leafpad /etc/modules</span><br></pre></td></tr></table></figure><p>添加下面两行到模块配置文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lirc-dev</span><br><span class="line"><span class="comment">#红外接收模块的OUT接口接到了树莓派的GPIO18</span></span><br><span class="line"><span class="comment">#因为本例中未用到红外发射模块，所以后面的gpio_out_pin可以不写</span></span><br><span class="line">lirc-rpi gpio_in_pin=<span class="number">18</span> gpio_out_pin=<span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>如测试时报错-ERROR: could not insert ‘lirc_rpi’: No&amp;nbs</strong><br>解决办法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> /boot/config.txt</span><br></pre></td></tr></table></figure><p>找到：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#dtoverlay=lirc-rpi</span><br></pre></td></tr></table></figure><p>把前面的“#”号去掉， 然后重启系统即可</p><p><strong>测试红外线接收功能</strong><br>首先关闭lirc软件，然后执行如下命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/lirc <span class="keyword">stop</span></span><br><span class="line">mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure><p>这时候提示</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">no</span> such <span class="keyword">file</span> <span class="built_in">or</span> directory</span><br></pre></td></tr></table></figure><p>经过查看发现 &#x2F;dev 下面没有 lirc0 这个module，发现在&#x2F;boot&#x2F;config.txt里面dtoverlay&#x3D;lirc-rpi<br>取消注释，然后reboot，问题解决。</p><p>再次执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure><p>如果弹出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Partial <span class="keyword">read</span> <span class="number">8</span> bytes <span class="keyword">on</span> /dev/lirc0pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><p>发生错误，解决方案：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changed the following two lines in </span><br><span class="line">/etc/lirc/lirc_options.<span class="keyword">conf</span></span><br><span class="line">driver = default</span><br></pre></td></tr></table></figure><p>（尝试过程中第一次仍然无效，但是第二次重装系统后正常，目前未知原理）<br>如果显示下面内容</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pulse <span class="number">629</span></span><br><span class="line">space <span class="number">518</span></span><br><span class="line">pulse <span class="number">627</span></span><br><span class="line">space <span class="number">523</span></span><br><span class="line">pulse <span class="number">628</span></span><br><span class="line">space <span class="number">523</span></span><br><span class="line">pulse <span class="number">631</span></span><br><span class="line">space <span class="number">517</span></span><br><span class="line">pulse <span class="number">629</span></span><br></pre></td></tr></table></figure><p>则说明接收正常.</p><p>#协议<br>采用脉宽调制的串行码，以脉宽为0.565ms、间隔0.56ms、周期为1.125ms的组合表示二进制的”0”；以脉宽为0.565ms、间隔1.685ms、周期为2.25ms的组合表示二进制的”1<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议.png" alt><br>协议：<br>上述“0”和“1”组成的32位二进制码经38kHz的载频进行二次调制以提高发射效率，达到降低电源功耗的目的。然后再通过红外发射二极管产生红外线向空间发射，如下图。<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议2.png" alt><br>|    引导码    |  用户识别码   |用户识别码反码 |   操作码    |  操作码反码   |<br>一个命令只发送一次，即使遥控器上的按键一直按着。但是会每110mS发送一次代码，直到遥控器按键释放。</p><p>重复码比较简单：一个9mS的AGC脉冲、2.25mS间隔、560uS脉冲。<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议3.png" alt><br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议4.png" alt></p><h1><span id="读取并校验接收-对应到的红外信号">读取并校验接收、对应到的红外信号</span></h1><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/代码1.png" alt>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派GPIO控制的初级应用-多色二极管的亮度调节与颜色变化</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/</id>
    <published>2019-03-02T01:16:06.000Z</published>
    <updated>2022-09-28T05:55:12.340Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/多色二极管.png" alt><span id="more"></span><p>引脚R：控制红色二极管亮&#x2F;灭<br>引脚G：控制绿色二极管亮&#x2F;灭<br>引脚B：控制蓝色二极管亮&#x2F;灭<br>GND：接地</p><p>在这里我们令各个引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R=<span class="number">13</span> </span><br><span class="line">G=<span class="number">26</span> </span><br><span class="line">B=<span class="number">16</span></span><br></pre></td></tr></table></figure><p>初始化各个引脚</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RPi.GPIO.setup(R,RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(G,RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(B,RPi.GPIO.OUT)</span><br></pre></td></tr></table></figure><p>初始化脉宽调制为最大并启动</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwmR = RPi.GPIO.PWM(R,<span class="number">100</span>)</span><br><span class="line">pwmG = RPi.GPIO.PWM(G,<span class="number">100</span>)</span><br><span class="line">pwmB = RPi.GPIO.PWM(B,<span class="number">100</span>)</span><br><span class="line">pwmR.start(<span class="number">0</span>)</span><br><span class="line">pwmG.start(<span class="number">0</span>)</span><br><span class="line">pwmB.start(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>以红色灯为例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">红灯亮：RPi.GPIO.output(R,<span class="literal">True</span>)</span><br><span class="line">红灯灭：RPi.GPIO.output(R,<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>亮度调节：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">红灯<span class="number">1</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=1</span></span><br><span class="line">红灯<span class="number">2</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=20</span></span><br><span class="line">红灯<span class="number">3</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=50</span></span><br><span class="line">红灯<span class="number">4</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=100</span></span><br></pre></td></tr></table></figure><p>颜色调节：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红灯：红色二极管亮</span><br><span class="line">蓝灯：蓝色二极管亮</span><br><span class="line">绿灯：绿色二极管亮</span><br><span class="line">黄色灯：红色、绿色二极管同时亮</span><br><span class="line">白色灯：红色、蓝色、绿色灯同时亮</span><br></pre></td></tr></table></figure><p>同时控制亮度和颜色方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当接收到红外信号时，内部计数器+<span class="number">1</span> 并对<span class="number">25</span>求余</span><br><span class="line">当计数器为<span class="number">4</span> <span class="number">9</span> <span class="number">14</span> <span class="number">19</span> <span class="number">24</span>时，表示灯熄灭</span><br><span class="line"><span class="number">0</span>~<span class="number">3</span>时表示红灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">5</span>~<span class="number">8</span>时表示绿灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">10</span>~<span class="number">13</span>时表示蓝灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">15</span>~<span class="number">18</span>时表示黄灯，具体计数器数值表示红灯和绿灯亮度对应的字典下标</span><br><span class="line"><span class="number">20</span>~<span class="number">23</span>时表示白灯，具体计数器数值表示红灯、绿灯和蓝灯亮度对应的字典下标</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基于树莓派GPIO控制的介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派引脚介绍与GPIO的初步认识与应用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-02T01:03:20.000Z</published>
    <updated>2022-09-27T16:58:33.957Z</updated>
    
    <content type="html"><![CDATA[<p>​下图所示为树莓派3b+开发板。上方引脚处左下角引脚为1号引脚。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/树莓派.png" alt style="zoom:10%;"><span id="more"></span><h1><span id="一认识gpio">一．认识GPIO</span></h1><p>所谓GPIO，就是“通用输入&#x2F;输出”接口，树莓派系统中已经编译自带了GPIO的驱动。</p><p><strong>树莓派GPIO的编号方式：</strong></p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/引脚.png" alt><p><strong>1.功能物理引脚（physical）：</strong><br>从左到右，从上到下。左边为奇数，右边为偶数。共计40个引脚，计数为1-40。<br><strong>2.BCM：</strong><br>编号侧重于CPU寄存器，根据BCM2835的GPIO寄存器编号。具体编号参照上图中BCM一栏。<br><strong>3.wiringPi</strong><br>编号侧重实现逻辑，把GPIO端口从0开始编号，这种编号方便编程，参考上图wPi一栏。</p><p>三种编号的方式均指代的对象相同，只是编码方式不同。</p><p><strong>其中</strong><br>GPIO.**: 通用输入输出接口，GPIO端口，可通过软件分别配置成输入或输出。<br>3.3V&#x2F;5.0V(VCC):提供3.3V&#x2F;5.0V的固定电压<br>0V（GND）：接地<br>SDA<em>：SDA 是I2C 数据传输口。<br>SCL：I2C时钟信号。<br>RXD：接收数据的引脚。<br>TXD：发送数据的引脚。<br>MOSI：为主输出从输入。<br>MISO：为主输入从输出。<br>SCLK: 系统时钟,指晶振频率。<br>CE</em>：片选（芯片有效）-表示低电平有效</p><h1><span id="二python-gpio">二．Python GPIO</span></h1><p>默认的python GPIO均已集成入raspbian系统，不需要另外安装。<br>如果需要安装，请按以下顺序：<br>1、先安装python-dev，输入以下指令。<br>      sudo apt-get install python-dev<br>2、安装RPi.GPIO，依次输入以下指令。<br>1)下载：wget <a href="http://raspberry-gpio-python.googlecode.com/files/RPi.GPIO-0.5.3a.tar.gz">http://raspberry-gpio-python.googlecode.com/files/RPi.GPIO-0.5.3a.tar.gz</a><br>2)解压缩：tar xvzf RPi.GPIO-0.5.3a.tar.gz<br>3)进入解压之后的目录： cd RPi.GPIO-0.5.3a<br>4)启动安装 ： sudo python setup.py install</p><h1><span id="三应用">三．应用</span></h1><p><strong>导入模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import RPi.GPIO as GPIO</span><br></pre></td></tr></table></figure><p><strong>设置引脚引用模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setmode(GPIO.BOARD)</span><br><span class="line">#or</span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br></pre></td></tr></table></figure><p><strong>检测使用的哪种模式可以使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mode=GPIO.getmode()</span><br><span class="line">#mode的取值有GPIO.BOARD, GPIO.BCM, None</span><br></pre></td></tr></table></figure><p>以下代码如无特殊说明，均使用GPIO.BOARD引脚映射模式。</p><p><strong>设置引脚方向（输入，输出）:</strong></p><p>如 设置40号引脚为输入方向：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pin = <span class="number">40</span></span><br><span class="line">GPIO.setup(pin,GPIO.IN)</span><br></pre></td></tr></table></figure><p>输出同理：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setup(pin,GPIO.OUT)</span><br><span class="line"><span class="comment">#输出还可以加初始电平：</span></span><br><span class="line">GPIO.setup(pin,GPIO.OUT,initial=GPIO.HIGH)</span><br><span class="line">如果要同时设置多个引脚：</span><br><span class="line"><span class="built_in">list</span>=[<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">GPIO.setup(<span class="built_in">list</span>,GPIO.OUT)</span><br></pre></td></tr></table></figure><p>如果要同时设置多个引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">GPIO.setup(<span class="built_in">list</span>,GPIO.OUT)</span><br></pre></td></tr></table></figure><p><strong>释放</strong><br>一般来说，程序到达最后都需要释放资源，这个好习惯可以避免偶然损坏树莓派。释放脚本中的使用的引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.cleanup()</span><br></pre></td></tr></table></figure><p><strong>警告</strong><br>如果RPi.GRIO检测到一个引脚已经被设置成了非默认值，那么你将看到一个警告信息。你可以通过下列代码禁用警告：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setwarnings(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>注意，GPIO.cleanup()只会释放掉脚本中使用的GPIO引脚，并会清除设置的引脚编号规则。</p><p><strong>读取</strong><br>我们也常常需要读取引脚的输入状态，获取引脚输入状态如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO.input(channel)</span><br><span class="line">#低电平返回0 / GPIO.LOW / False，高电平返回1 / GPIO.HIGH / True。</span><br></pre></td></tr></table></figure><p>如果输入引脚处于悬空状态，引脚的值将是漂动的。<br>换句话说，读取到的值是未知的，因为它并没有被连接到任何的信号上，直到按下一个按钮或开关。<br>由于干扰的影响，输入的值可能会反复的变化。<br>使用如下代码可以解决问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_UP)  </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)</span><br><span class="line"><span class="comment">#需要注意的是，上面的读取代码只是获取当前一瞬间的引脚输入信号。</span></span><br></pre></td></tr></table></figure><p>如果需要实时监控引脚的状态变化，可以有两种办法。<br>最简单原始的方式是每隔一段时间检查输入的信号值，这种方式被称为轮询。<br>如果你的程序读取的时机错误，则很可能会丢失输入信号。<br>轮询是在循环中执行的，这种方式比较占用处理器资源。<br><strong>轮询方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while GPIO.input(channel) == GPIO.LOW:</span><br><span class="line">    time.sleep(0.01)  # wait 10 ms to give CPU chance to do other things</span><br></pre></td></tr></table></figure><p>另一种响应GPIO输入的方式是使用中断（边缘检测），这里的边缘是指信号从高到低的变换（下降沿）或从低到高的变换（上升沿）。<br><strong>边缘检测</strong><br>边缘是指信号状态的改变，从低到高（上升沿）或从高到低（下降沿）。通常情况下，我们更关心于输入状态的该边而不是输入信号的值。这种状态的该边被称为事件。</p><p>wait_for_edge() 函数<br>wait_for_edge()被用于阻止程序的继续执行，直到检测到一个边缘。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel = GPIO.wait_for_edge(channel, GPIO_RISING, timeout=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>add_event_detect() 函数<br>该函数对一个引脚进行监听，一旦引脚输入状态发生了改变，调用event_detected()函数会返回true，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO.add_event_detect(channel, GPIO.RISING)</span><br><span class="line"><span class="keyword">if</span> GPIO.event_detected(channel):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Button pressed&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>RPI.GPIO 模块的脉宽调制（PWM）功能</strong><br>脉宽调制(PWM)是指用微处理器的数字输出来对模拟电路进行控制，是一种对模拟信号电平进行数字编码的方法。在树莓派上，可以通过对GPIO的编程来实现PWM。<br>创建一个 PWM 实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = GPIO.PWM(channel, frequency)</span><br></pre></td></tr></table></figure><p>启用 PWM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.start(dc)   # dc 代表占空比（范围：0.0 &lt;= dc &lt;= 100.0）</span><br></pre></td></tr></table></figure><p>更改频率：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ChangeFrequency(freq)   <span class="comment"># freq 为设置的新频率，单位为 Hz</span></span><br></pre></td></tr></table></figure><p>更改占空比：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ChangeDutyCycle(dc)  <span class="comment"># 范围：0.0 &lt;= dc &gt;= 100.0</span></span><br></pre></td></tr></table></figure><p>停止 PWM：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.stop()</span><br><span class="line"><span class="comment">#注意，如果实例中的变量“p”超出范围，也会导致 PWM 停止。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
</feed>
