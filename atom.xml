<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Angelo的代码工坊</title>
  
  <subtitle>I shut my eyes in order to see.</subtitle>
  <link href="https://values.keys.moe/atom.xml" rel="self"/>
  
  <link href="https://values.keys.moe/"/>
  <updated>2022-09-27T13:23:30.538Z</updated>
  <id>https://values.keys.moe/</id>
  
  <author>
    <name>Angelo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World !</title>
    <link href="https://values.keys.moe/2022/09/26/hello-world/"/>
    <id>https://values.keys.moe/2022/09/26/hello-world/</id>
    <published>2022-09-26T14:28:42.065Z</published>
    <updated>2022-09-27T13:23:30.538Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>通过Xrdp实现Windows远程访问Ubuntu 16.04</title>
    <link href="https://values.keys.moe/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/"/>
    <id>https://values.keys.moe/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/</id>
    <published>2019-03-05T03:25:45.000Z</published>
    <updated>2022-09-28T06:24:41.208Z</updated>
    
    <content type="html"><![CDATA[<p>​目前网上的大量教程都是需要安装xfac4或者xubuntu桌面系统才能实现远程连接。因为xrdp支持在13.10之后版本就已经不支持的Gnome了和原生Unity桌面，所以网上很多方法都是安装能够被xdrp支持的第三方xfac4或者xubuntu桌面系统间接达到远程控制Ubuntu。<br>​本文提供如何使用Xrdp访问原生Ubuntu桌面。</p><span id="more"></span><h2><span id="step1-下载tigervnc-server软件包">Step.1 下载TigerVNC Server软件包</span></h2><p>下载地址：<br><a href="http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip">http://www.c-nergy.be/downloads/tigervncserver_1.6.80-4_amd64.zip</a></p><h2><span id="step2-安装tigervnc-server">Step.2 安装TigerVNC Server</span></h2><p>1.打开终端，进入到刚刚你你下载TigerVNC Server的存放目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> 下载</span><br></pre></td></tr></table></figure><p>2.执行安装指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i tigervncserver_1.<span class="number">6.80</span>-<span class="number">4</span>_amd64.<span class="keyword">deb</span></span><br><span class="line">或者</span><br><span class="line">sudo apt-<span class="built_in">get</span> install tightvncserver</span><br></pre></td></tr></table></figure><p>过程中如果出现警告信息和错误信息，原因是没有相对应的依赖包。<br>执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">f</span></span><br></pre></td></tr></table></figure><p>然后在执行之前的安装命令。</p><h2><span id="step3-安装xrdp">Step.3 安装Xrdp</span></h2><p>终端输入安装命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install xrdp -<span class="keyword">y</span></span><br></pre></td></tr></table></figure><h2><span id="step4-配置xrdp">Step.4 配置Xrdp</span></h2><p>需要通过xrdp连接到桌面，<br>需要正确配置相关信息并填充到.xsession文件（针对每个用户）<br>或&#x2F;etc&#x2F;startwm.sh（针对所有用户）<br>命令如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> unity&gt;~/.xsession</span><br><span class="line">或者</span><br><span class="line">sudo sed -i.bak <span class="string">&#x27;/fi/a #xrdp multi-users \n unity \n&#x27;</span> /etc/xrdp/startwm.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><h2><span id="step5-重启xrdp服务">Step.5 重启Xrdp服务</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure><h2><span id="step6-开启桌面共享功能">Step.6 开启桌面共享功能</span></h2><img src="/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/桌面共享.jpg" alt><p>系统-&gt;首选项-&gt;桌面共享，或者直接搜索桌面共享功能<br>进入后<br>将【允许其他人查看您的桌面】勾上，<br>【自动配置UPnP路由器开放和转发接口】勾上，如图所示</p><img src="/2019/03/05/%E9%80%9A%E8%BF%87Xrdp%E5%AE%9E%E7%8E%B0Windows%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEUbuntu-16-04/桌面共享2.jpg" alt><p>之后配置基本结束。Windows可以通过mstc直接通过IP访问Ubuntu。</p><hr><p>注：Ubuntu18尝试后似乎没有桌面共享功能的选项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;​		目前网上的大量教程都是需要安装xfac4或者xubuntu桌面系统才能实现远程连接。因为xrdp支持在13.10之后版本就已经不支持的Gnome了和原生Unity桌面，所以网上很多方法都是安装能够被xdrp支持的第三方xfac4或者xubuntu桌面系统间接达到远程控制Ubuntu。&lt;br&gt;​		本文提供如何使用Xrdp访问原生Ubuntu桌面。&lt;/p&gt;</summary>
    
    
    
    <category term="Ubuntu" scheme="https://values.keys.moe/categories/Ubuntu/"/>
    
    
    <category term="Ubuntu" scheme="https://values.keys.moe/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>树莓派人脸识别-face-recognition的安装与应用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-02T03:06:57.000Z</published>
    <updated>2022-09-27T17:08:54.800Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/人脸识别.gif" alt><span id="more"></span><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/face_recongnition.png" alt>该库可以通过python或者命令行即可实现人脸识别的功能。使用dlib深度学习人脸识别技术构建，在户外脸部检测数据库基准（Labeled Faces in the Wild）上的准确率为99.38%。<h2><span id="安装过程"><strong>安装过程</strong></span></h2><p>先在终端下安装一大堆需要的库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span> sudo apt-<span class="built_in">get</span> install build-essential \</span><br><span class="line">cmake \</span><br><span class="line">gfortran \</span><br><span class="line">git \</span><br><span class="line">wget \</span><br><span class="line">curl \</span><br><span class="line">graphicsmagick \</span><br><span class="line">libgraphicsmagick1-dev \</span><br><span class="line">libatlas-dev \</span><br><span class="line">libavcodec-dev \</span><br><span class="line">libavformat-dev \</span><br><span class="line">libboost-<span class="keyword">all</span>-dev \</span><br><span class="line">libgtk2.<span class="number">0</span>-dev \</span><br><span class="line">libjpeg-dev \</span><br><span class="line">liblapack-dev \</span><br><span class="line">libswscale-dev \</span><br><span class="line">pkg-config \</span><br><span class="line"><span class="keyword">python3</span>-dev \</span><br><span class="line"><span class="keyword">python3</span>-numpy \</span><br><span class="line"><span class="keyword">python3</span>-pip \</span><br><span class="line">zip</span><br></pre></td></tr></table></figure><p>如果使用树莓派的摄像头（CSI接口），执行下面的命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install <span class="keyword">python3</span>-picamera</span><br><span class="line">sudo pip3 install --upgrade picamera[array]</span><br></pre></td></tr></table></figure><p>下载安装dlib：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> dlib </span><br><span class="line">git clone -<span class="keyword">b</span> <span class="string">&#x27;v19.6&#x27;</span> --single-branch https://github.<span class="keyword">com</span>/davisking/dlib.git dlib/ </span><br><span class="line"><span class="keyword">cd</span> ./dlib</span><br><span class="line">sudo <span class="keyword">python3</span> setup.<span class="keyword">py</span> install --<span class="keyword">compiler</span>-flags <span class="string">&quot;-mfpu=neon&quot;</span></span><br></pre></td></tr></table></figure><p>安装face_recognition：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install face_recognition</span><br></pre></td></tr></table></figure><p>下载示例代码并尝试运行（可选）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone --single-branch https://github.<span class="keyword">com</span>/ageitgey/face_recognition.git</span><br><span class="line"><span class="keyword">cd</span> ./face_recognition/examples</span><br><span class="line"><span class="keyword">python3</span> facerec_on_raspberry_pi.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p><strong>注</strong>：过程缺少库时，使用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache <span class="built_in">search</span> 库名</span><br></pre></td></tr></table></figure><p>来搜索到那个库的安装包，然后用</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install 包名</span><br></pre></td></tr></table></figure><p>来安装。</p><p><strong>例如</strong>：缺少了libatlas.so.3，那我们就用<strong>apt-cache search libatlas</strong>来搜索，发现它的包名叫libatlas3-base，所以我们用<strong>sudo apt-get install libatlas3-base</strong>来安装。<br>后面测试摄像头的时候也会遇到这样的问题，解决办法是一样的。 </p><p>待把CSI接口树莓派摄像头装上后，在raspi-config中启用摄像头，然后重启。<br>（详见博客内关于CSI摄像头的另一篇文章）</p><p>运行一下实时人脸识别的代码（可选）：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> facerec_from_webcam_faster.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>过程可能报错，import cv2的时候缺少库，然后根据提示用之前安装方法安装就好了。装完一个库再运行的时候，发现又提示缺少别的库，然后再安装缺少的库。反复个多次，把缺少的库都装好即可。</p><p>再次运行的时候，会报别的错误，出错的代码是</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">small_frame = cv2.<span class="keyword">resize</span>(frame, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.25</span>, fy=<span class="number">0.25</span>)</span><br></pre></td></tr></table></figure><p>这是因为video_capture.read()没有读到图片。<br>树莓派中的camera module是放在&#x2F;boot&#x2F;目录中以固件形式加载的，不是一个标准的V4L2的摄像头驱动，所以加载起来之后会找不到&#x2F;dev&#x2F;video0的设备节点。<br><strong>解决方法</strong>：转载<a href="https://blog.csdn.net/deiki/article/details/71123947">https://blog.csdn.net/deiki/article/details/71123947</a></p><p>之后可以使用下面的命令来加载驱动模块：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>如果想开机自动加载，我们可以修改&#x2F;etc&#x2F;modules文件，添加一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>如下图所示：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-face-recognition%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%BA%94%E7%94%A8/bcm2835-v4l2.png" alt></p><p>安装过程基本完毕。</p><h2><span id="个人提供的样例代码"><strong>个人提供的样例代码：</strong></span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env </span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#从目录中读取一堆文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> RPi.GPIO</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">RPi.GPIO.setmode(RPi.GPIO.BCM)</span><br><span class="line"></span><br><span class="line">RPi.GPIO.setwarnings(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">buzzer=<span class="number">4</span></span><br><span class="line">RPi.GPIO.setup(buzzer,RPi.GPIO.OUT)</span><br><span class="line"></span><br><span class="line">RPi.GPIO.output(buzzer,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">strangerAppear=<span class="literal">False</span></span><br><span class="line">strangerNum=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo_filelist=[]</span><br><span class="line">demo_face_encodings=[]</span><br><span class="line">demo_face_names=[]</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">&#x27;/home/pi/demo/face_recognition/jpg//&#x27;</span>):</span><br><span class="line">    demo_filelist.append(f)</span><br><span class="line">    demo_face_names.append(f[:-<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> demo_filelist:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">u&#x27;正在加载....&#x27;</span>+filename)</span><br><span class="line">    demo_image = face_recognition.load_image_file(<span class="string">&#x27;/home/pi/demo/face_recognition/jpg//&#x27;</span>+filename)</span><br><span class="line">    face_encoding = face_recognition.face_encodings(demo_image)[<span class="number">0</span>]</span><br><span class="line">    demo_face_encodings.append(face_encoding)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize some variables</span></span><br><span class="line">face_locations = []</span><br><span class="line">face_encodings = []</span><br><span class="line">face_names = []</span><br><span class="line">process_this_frame = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get a reference to webcam #0 (the default one)</span></span><br><span class="line">video_capture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Grab a single frame of video</span></span><br><span class="line">    ret, frame = video_capture.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Resize frame of video to 1/4 size for faster face recognition processing</span></span><br><span class="line">    small_frame = cv2.resize(frame, (<span class="number">0</span>, <span class="number">0</span>), fx=<span class="number">0.3</span>, fy=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Only process every other frame of video to save time</span></span><br><span class="line">    <span class="keyword">if</span> process_this_frame==<span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Find all the faces and face encodings in the current frame of video</span></span><br><span class="line">        face_locations = face_recognition.face_locations(small_frame)</span><br><span class="line">        face_encodings = face_recognition.face_encodings(small_frame, face_locations)</span><br><span class="line">   <span class="comment">#     print(u&quot;我检测到了&#123;&#125;张脸。&quot;.format(len(face_locations)))</span></span><br><span class="line">        face_names = []</span><br><span class="line">        <span class="keyword">for</span> face_encoding <span class="keyword">in</span> face_encodings:</span><br><span class="line">        <span class="comment"># See if the face is a match for the known face(s)</span></span><br><span class="line">            <span class="keyword">match</span> = face_recognition.compare_faces(demo_face_encodings, face_encoding,tolerance=<span class="number">0.6</span>)<span class="comment">#</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="keyword">match</span>)</span><br><span class="line">            name = <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">            i=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="keyword">match</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> m:</span><br><span class="line">                    name= demo_face_names[i]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(name==<span class="string">&quot;Unknown&quot;</span>):</span><br><span class="line">                RPi.GPIO.output(buzzer,<span class="literal">False</span>)</span><br><span class="line">                frame_1=cv2.flip(frame,<span class="number">1</span>)</span><br><span class="line">                path=<span class="string">&quot;/home/pi/demo/face_recognition/&quot;</span>+<span class="built_in">str</span>(strangerNum)+<span class="string">&quot;.png&quot;</span></span><br><span class="line">                cv2.imwrite(path,frame_1)</span><br><span class="line">                strangerNum=strangerNum+<span class="number">1</span></span><br><span class="line">                strangerAppear=<span class="literal">True</span></span><br><span class="line">            face_names.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Display the results</span></span><br><span class="line">    <span class="keyword">for</span> (top, right, bottom, left), name <span class="keyword">in</span> <span class="built_in">zip</span>(face_locations, face_names):</span><br><span class="line">        <span class="comment"># Draw a box around the face</span></span><br><span class="line">        <span class="comment">#cv2.rectangle(frame, (left, top), (right, bottom), (0, 0, 255), 2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Draw a label with a name below the face</span></span><br><span class="line"><span class="comment">#        cv2.rectangle(frame, (left, bottom - 35), (right, bottom), (0, 0, 255), 5)</span></span><br><span class="line">        font = cv2.FONT_HERSHEY_DUPLEX<span class="comment">#FONT_HERSHEY_DUPLEX</span></span><br><span class="line"><span class="comment">#        print(name)</span></span><br><span class="line"><span class="comment">#        boxsize, _ = cv2.getTextSize(fs.string, fs.face, fs.fsize, fs.thick)</span></span><br><span class="line"> <span class="comment">#       locx = int((right+left)/2-25 - 14*len(name)/2)</span></span><br><span class="line">        cv2.putText(frame, name, (<span class="number">20</span>,<span class="number">20</span>), font, <span class="number">1.0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    process_this_frame += <span class="number">1</span><span class="comment"># not process_this_frame</span></span><br><span class="line">    <span class="keyword">if</span> process_this_frame&gt;<span class="number">1</span>:</span><br><span class="line">        process_this_frame=<span class="number">1</span></span><br><span class="line">    <span class="comment"># Display the resulting image</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">############</span></span><br><span class="line">    cv2.imshow(<span class="string">&#x27;Video&#x27;</span>, frame)</span><br><span class="line">    cv2.moveWindow(<span class="string">&#x27;Video&#x27;</span>,<span class="number">600</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Hit &#x27;q&#x27; on the keyboard to quit!</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        RPi.GPIO.output(buzzer,<span class="literal">True</span>)</span><br><span class="line">        strangerAppear=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Release handle to the webcam</span></span><br><span class="line">video_capture.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派CSI摄像头的连接与常用指令</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-03-02T01:28:19.000Z</published>
    <updated>2022-09-28T06:03:44.256Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/CSI摄像头.jpg" alt><span id="more"></span><h1><span id="安装树莓派摄像头模块">安装树莓派摄像头模块</span></h1><p>​1、找到 CSI 接口(CSI接口在以太网接口旁边)，掀起深色胶带。<br>​2、拉起 CSI 接口挡板。<br>​3、拿起你的摄像头模块，将贴在镜头上的塑料保护膜撕掉。确保黄色部分的PCB(有字的一面)是安装完美的（可以轻轻按一下黄色的部分来保证安装完美）。<br>​4、将排线插入CSI接口。记住，有蓝色胶带的一面应该面向以太网接口方向。同样，这时也确认一下排线安装好了之后，将挡板拉下。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/安装图.jpg" alt><h1><span id="在树莓派上启用摄像头模块">在树莓派上启用摄像头模块</span></h1><p>在安装完摄像头模块之后，首先要确认你已经升级了树莓派系统并应用了最新的固件。<br>终端下可以输入以下命令来操作：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span>   </span><br><span class="line">sudo apt-<span class="built_in">get</span> upgrade </span><br></pre></td></tr></table></figure><p>运行树莓派配置工具来激活摄像头模块：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>移动光标至菜单中的 “Enable Camera（启用摄像头）”，将其设为Enable（启用状态）。完成之后重启树莓派。</p><h1><span id="安装驱动使能树莓派的相关模块">安装驱动使能树莓派的相关模块</span></h1><h2><span id="1-添加驱动程序文件进来">1、添加驱动程序文件进来：</span></h2><p>终端输入指令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/modules</span><br></pre></td></tr></table></figure><p>在最后添加如下的代码：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>这样就完成了在启动过程中加载camera驱动的前提。</p><h2><span id="2-修改raspberry的启动配置使能项">2、修改Raspberry的启动配置使能项：</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure> <img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/配置1.jpg" alt><p>(由于系统版本，树莓派版本不同，显示设置可能不同，但基本大同小异。)<br>选择Interfacing Option，选中Select然后Enter进入，如下图所示： </p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/配置2.jpg" alt><h2><span id="3-检查x2fdev下面是否存在摄像头设备">3、检查&#x2F;dev下面是否存在摄像头设备</span></h2><p>重启完之后，我们的基本的操作就完成了，下来来看看&#x2F;dev下面是否存在摄像头设备的问题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -al /dev/ | grep video</span><br></pre></td></tr></table></figure><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BECSI%E6%91%84%E5%83%8F%E5%A4%B4%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/检查.jpg" alt><h1><span id="使用操作树莓派的摄像头">使用操作树莓派的摄像头</span></h1><p>下面简单的使用操作树莓派的摄像头：<br>1、我们使用rapistill指令来截图</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspistill -<span class="keyword">o</span> image.jpg</span><br></pre></td></tr></table></figure><p>raspistill命令的相关参数和实验的具体效果：<br>-v：调试信息查看<br>-w：图像宽度<br>-h：图像高度<br>-rot：图像旋转角度，只支持 0、90、180、270 度（这里说明一下，测试发现其他角度的输入都会被转换到这四个角度之上）<br>-o：图像输出地址，例如image.jpg，如果文件名为“-”，将输出发送至标准输出设备<br>-t：获取图像前等待时间，默认为5000，即5秒<br>-tl：多久执行一次图像抓取<br>使用raspivid指令来生成.h246的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raspivid -<span class="keyword">o</span> mykeychain.h264 -t <span class="number">10000</span> -<span class="keyword">w</span> <span class="number">1280</span> -h <span class="number">720</span> </span><br></pre></td></tr></table></figure><p>如果你想改变拍摄时长，只要通过 “-t” 选项来设置你想要的长度就行了（单位是毫秒）。<br>如果你想改变图像的分辨率，使用 “-w” 和 “-h” 选项将分辨率降为 1280x720等等。</p>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派常见问题与解决方案</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2019-03-02T01:26:05.000Z</published>
    <updated>2022-09-28T06:28:27.634Z</updated>
    
    <content type="html"><![CDATA[<p>又是老问题？（笑</p><span id="more"></span><h1><span id="树莓派有密码的网络联网失败的问题与解决">树莓派有密码的网络联网失败的问题与解决</span></h1><p><strong>在保证系统无任何修改的情况下：</strong><br>树莓派出现无法连接有密码的网络，而可以连接无密码网络的情况。<br>问题出现原因：<strong>电池电源电流供应不足</strong>。<br>解决方案：给树莓派micrioUSB处通以<strong>正常电源</strong>，问题得以解决。</p><h1><span id="修改树莓派热点的名称和密码">修改树莓派热点的名称和密码</span></h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/hostapd/hostapd.<span class="keyword">conf</span> </span><br></pre></td></tr></table></figure><p>其中ssid为热点的名称、wpa_passphrase为热点的密码<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/修改树莓派热点的名称和密码.jpg" alt></p><h1><span id="树莓派更换国内可用镜像源">树莓派更换国内可用镜像源</span></h1><p>***最新系统不用折腾换源了，亲测官方源可以使用。</p><p><strong>查看树莓派的镜像列表</strong><br><a href="http://www.raspbian.org/RaspbianMirrors">http://www.raspbian.org/RaspbianMirrors</a><br>操作</p><h2><span id="1-编辑sourceslist">1. 编辑sources.list</span></h2><p>打开终端 输入</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>用#注释或直接删除原有的内容，新增两条：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line">#deb-src http://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspbian/raspbian/ stretch main contrib non-free rpi</span><br></pre></td></tr></table></figure><p>ctrl+x 保存并退出。</p><h2><span id="2-编辑raspilist">2. 编辑raspi.list</span></h2><p>sudo nano &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list<br>用#注释或直接删除原有的内容，新增两条：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirror.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspberrypi/ stretch main ui</span><br><span class="line">#deb-src http://mirror.tuna.tsinghua.edu.<span class="keyword">cn</span>/raspberrypi/ stretch main ui</span><br></pre></td></tr></table></figure><p>ctrl+x 保存并退出。</p><h2><span id="3-更新软件源列表">3. 更新软件源列表</span></h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;又是老问题？（笑&lt;/p&gt;</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>树莓派空气质量检测仪-攀藤G5003ST的连接与使用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2019-03-02T01:23:34.000Z</published>
    <updated>2022-09-28T05:44:45.667Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/5003ST正.jpg" alt><span id="more"></span><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/5003ST反.jpg" alt><h1><span id="攀藤g5003st数字接口定义">攀藤G5003ST数字接口定义</span></h1><p><strong>pin1(VCC)</strong>:连接电压为3.3V&#x2F;5V电压<br><strong>pin2(GND)</strong> 电源-<br>**pin3(SET待机位置)**，设置管脚?&#x2F;TTL电平@3.3V，高电平或悬空为正常工作状态，低电平为休眠状态，该引脚可悬空。<br><strong>pin4(RXD串口接收管脚)</strong> 传感器接收来自树莓派的信号数据，如果不需要可以悬空<br><strong>pin5(TXD串口发送管脚)</strong> 传感器将信号发送给树莓派<br><strong>pin6(RESET)</strong> 模块复位信号&#x2F;TTL电平@3.3V，低复位，如果不需要使用可以悬空<br><strong>pin7(NC)</strong> : No internal connection. 无内部连接，不需连接。<br><strong>Pin8(NC&#x2F;PWM)</strong> : PWM周期为1s，其中低电平对应大气环境下的PM2.5质量浓度数据，每1ms低电平代表1ug&#x2F;m?。例如低电平时间长度为210ms，则代表此时PM2.5质量浓度值（大气环境）为210ug&#x2F;m?<br><strong>（pin7和pin8为程序内部调试使用，应用电路中应该使其悬空）</strong></p><p>树莓派Pi3的UART（ttyAMA0）是被蓝牙默认占用的，更改起来十分困难，在实体机上尝试多次无果后决定使用USB TO TTL转接口，直接将PMS5003ST接至树莓派的USB接口上，这样可以直接在&#x2F;dev&#x2F;tty中直接检索到USB0，即为传感器。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/接线.jpg" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/接线2.jpg" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/pin口.png" alt><h1><span id="攀藤g5003st技术指标">攀藤G5003ST技术指标</span></h1><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标1.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标2.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标3.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/技术指标4.png" alt><h1><span id="攀藤g5003st输出结果分析">攀藤G5003ST输出结果分析</span></h1><p>1.颗粒物浓度：主要输出为单位体积内各浓度颗粒物质量以及个数，其中颗粒物个数的单位体积为0.1升，质量浓度单位为：微克&#x2F;立方米（μg&#x2F;m3）。<br>此外传感器输出分为主动输出和被动输出两种状态。<br>传感器上电后默认状态为主动输出，即传感器主动向主机发送串行数据，时间间隔为200 ~ 800ms，空气中颗粒物浓度越高，时间间隔越短。<br>主动输出又分为两种模式：平稳模式和快速模式。<br>在空气中颗粒物浓度变化较小时，传感器输出为平稳模式，即每三次输出同样的一组数值，实际数据更新周期约为2s。<br>当空气中颗粒物浓度变化较大时，传感器输出自动切换为快速模式，每次输出都是新的数值，实际数据更新周期为200~800ms。<br>PWM输出：PMS3XXXP系列产品带有PWM输出，PWM周期为1秒，低电平时间长度代表PM2.5浓度（大气环境下），每1ms低电平代表1ug&#x2F;m3。<br>例如：低电平时间长度为210ms，则代表此时PM2.5质量浓度值（大气环境）为210ug&#x2F;m3<br>2.甲醛浓度输出：单位体积内甲醛质量浓度，单位为毫克&#x2F;立方米<br>3.温湿度输出：输出吸入传感器内部的采样空气温度及湿度。</p><h1><span id="攀藤g5003st对外输出格式">攀藤G5003ST对外输出格式</span></h1><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式0.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式1.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式2.png" alt><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/输出格式3.png" alt><h1><span id="python程序实现">python程序实现</span></h1><p>读取数据：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/读取数据.png" alt></p><p>分析数据：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/分析数据.png" alt></p><p>得出数据结论：<br><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%A9%BA%E6%B0%94%E8%B4%A8%E9%87%8F%E6%A3%80%E6%B5%8B%E4%BB%AA-%E6%94%80%E8%97%A4G5003ST%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E4%BD%BF%E7%94%A8/数据结论.png" alt></p>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用lirc红外控制树莓派</title>
    <link href="https://values.keys.moe/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <id>https://values.keys.moe/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/</id>
    <published>2019-03-02T01:20:33.000Z</published>
    <updated>2022-09-28T06:09:54.964Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/红外传感器.png" alt><span id="more"></span><p>红外传感器<br>引脚从上到下分别为<br>IO GND VCC</p><h1><span id="lirc的安装与使用">lirc的安装与使用</span></h1><p>使用红外，首先需要安装树莓派的lirc模块<br>LIRC (Linux Infrared remote control)是一个linux系统下开源的软件包。这个软件可以让Linux系统接收及发送红外线信号。<br>注意事项：<br><strong>安装：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install lirc</span><br></pre></td></tr></table></figure><p>修改以下几处：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo leafpad /etc/lirc/hardware.<span class="keyword">conf</span></span><br><span class="line">LIRCD_ATGS=<span class="string">&quot;&quot;</span></span><br><span class="line">DRIVER=<span class="string">&quot;default&quot;</span></span><br><span class="line">DEVICE=<span class="string">&quot;/dev/lirc0&quot;</span></span><br><span class="line">MODULES=<span class="comment">&quot;lirc-rpi</span></span><br></pre></td></tr></table></figure><p>终端执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo leafpad /etc/modules</span><br></pre></td></tr></table></figure><p>添加下面两行到模块配置文件：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lirc-dev</span><br><span class="line"><span class="comment">#红外接收模块的OUT接口接到了树莓派的GPIO18</span></span><br><span class="line"><span class="comment">#因为本例中未用到红外发射模块，所以后面的gpio_out_pin可以不写</span></span><br><span class="line">lirc-rpi gpio_in_pin=<span class="number">18</span> gpio_out_pin=<span class="number">17</span></span><br></pre></td></tr></table></figure><p><strong>如测试时报错-ERROR: could not insert ‘lirc_rpi’: No&amp;nbs</strong><br>解决办法：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vi</span> /boot/config.txt</span><br></pre></td></tr></table></figure><p>找到：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#dtoverlay=lirc-rpi</span><br></pre></td></tr></table></figure><p>把前面的“#”号去掉， 然后重启系统即可</p><p><strong>测试红外线接收功能</strong><br>首先关闭lirc软件，然后执行如下命令：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/lirc <span class="keyword">stop</span></span><br><span class="line">mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure><p>这时候提示</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">no</span> such <span class="keyword">file</span> <span class="built_in">or</span> directory</span><br></pre></td></tr></table></figure><p>经过查看发现 &#x2F;dev 下面没有 lirc0 这个module，发现在&#x2F;boot&#x2F;config.txt里面dtoverlay&#x3D;lirc-rpi<br>取消注释，然后reboot，问题解决。</p><p>再次执行</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode2 -d /dev/lirc0</span><br></pre></td></tr></table></figure><p>如果弹出</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Partial <span class="keyword">read</span> <span class="number">8</span> bytes <span class="keyword">on</span> /dev/lirc0pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><p>发生错误，解决方案：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">changed the following two lines in </span><br><span class="line">/etc/lirc/lirc_options.<span class="keyword">conf</span></span><br><span class="line">driver = default</span><br></pre></td></tr></table></figure><p>（尝试过程中第一次仍然无效，但是第二次重装系统后正常，目前未知原理）<br>如果显示下面内容</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pulse <span class="number">629</span></span><br><span class="line">space <span class="number">518</span></span><br><span class="line">pulse <span class="number">627</span></span><br><span class="line">space <span class="number">523</span></span><br><span class="line">pulse <span class="number">628</span></span><br><span class="line">space <span class="number">523</span></span><br><span class="line">pulse <span class="number">631</span></span><br><span class="line">space <span class="number">517</span></span><br><span class="line">pulse <span class="number">629</span></span><br></pre></td></tr></table></figure><p>则说明接收正常.</p><p>#协议<br>采用脉宽调制的串行码，以脉宽为0.565ms、间隔0.56ms、周期为1.125ms的组合表示二进制的”0”；以脉宽为0.565ms、间隔1.685ms、周期为2.25ms的组合表示二进制的”1<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议.png" alt><br>协议：<br>上述“0”和“1”组成的32位二进制码经38kHz的载频进行二次调制以提高发射效率，达到降低电源功耗的目的。然后再通过红外发射二极管产生红外线向空间发射，如下图。<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议2.png" alt><br>|    引导码    |  用户识别码   |用户识别码反码 |   操作码    |  操作码反码   |<br>一个命令只发送一次，即使遥控器上的按键一直按着。但是会每110mS发送一次代码，直到遥控器按键释放。</p><p>重复码比较简单：一个9mS的AGC脉冲、2.25mS间隔、560uS脉冲。<br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议3.png" alt><br><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/协议4.png" alt></p><h1><span id="读取并校验接收-对应到的红外信号">读取并校验接收、对应到的红外信号</span></h1><img src="/2019/03/02/%E4%BD%BF%E7%94%A8lirc%E7%BA%A2%E5%A4%96%E6%8E%A7%E5%88%B6%E6%A0%91%E8%8E%93%E6%B4%BE/代码1.png" alt>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派GPIO控制的初级应用-多色二极管的亮度调节与颜色变化</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/</id>
    <published>2019-03-02T01:16:06.000Z</published>
    <updated>2022-09-28T05:55:12.340Z</updated>
    
    <content type="html"><![CDATA[<img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BEGPIO%E6%8E%A7%E5%88%B6%E7%9A%84%E5%88%9D%E7%BA%A7%E5%BA%94%E7%94%A8-%E5%A4%9A%E8%89%B2%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BA%AE%E5%BA%A6%E8%B0%83%E8%8A%82%E4%B8%8E%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96/多色二极管.png" alt><span id="more"></span><p>引脚R：控制红色二极管亮&#x2F;灭<br>引脚G：控制绿色二极管亮&#x2F;灭<br>引脚B：控制蓝色二极管亮&#x2F;灭<br>GND：接地</p><p>在这里我们令各个引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R=<span class="number">13</span> </span><br><span class="line">G=<span class="number">26</span> </span><br><span class="line">B=<span class="number">16</span></span><br></pre></td></tr></table></figure><p>初始化各个引脚</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RPi.GPIO.setup(R,RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(G,RPi.GPIO.OUT)</span><br><span class="line">RPi.GPIO.setup(B,RPi.GPIO.OUT)</span><br></pre></td></tr></table></figure><p>初始化脉宽调制为最大并启动</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwmR = RPi.GPIO.PWM(R,<span class="number">100</span>)</span><br><span class="line">pwmG = RPi.GPIO.PWM(G,<span class="number">100</span>)</span><br><span class="line">pwmB = RPi.GPIO.PWM(B,<span class="number">100</span>)</span><br><span class="line">pwmR.start(<span class="number">0</span>)</span><br><span class="line">pwmG.start(<span class="number">0</span>)</span><br><span class="line">pwmB.start(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>以红色灯为例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">红灯亮：RPi.GPIO.output(R,<span class="literal">True</span>)</span><br><span class="line">红灯灭：RPi.GPIO.output(R,<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>亮度调节：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">红灯<span class="number">1</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=1</span></span><br><span class="line">红灯<span class="number">2</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=20</span></span><br><span class="line">红灯<span class="number">3</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=50</span></span><br><span class="line">红灯<span class="number">4</span>级亮度：pwmR.ChangeDutyCycle(blightness[count1])  <span class="comment"># blightness[count1]=100</span></span><br></pre></td></tr></table></figure><p>颜色调节：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红灯：红色二极管亮</span><br><span class="line">蓝灯：蓝色二极管亮</span><br><span class="line">绿灯：绿色二极管亮</span><br><span class="line">黄色灯：红色、绿色二极管同时亮</span><br><span class="line">白色灯：红色、蓝色、绿色灯同时亮</span><br></pre></td></tr></table></figure><p>同时控制亮度和颜色方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当接收到红外信号时，内部计数器+<span class="number">1</span> 并对<span class="number">25</span>求余</span><br><span class="line">当计数器为<span class="number">4</span> <span class="number">9</span> <span class="number">14</span> <span class="number">19</span> <span class="number">24</span>时，表示灯熄灭</span><br><span class="line"><span class="number">0</span>~<span class="number">3</span>时表示红灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">5</span>~<span class="number">8</span>时表示绿灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">10</span>~<span class="number">13</span>时表示蓝灯，具体计数器数值表示亮度对应的字典下标</span><br><span class="line"><span class="number">15</span>~<span class="number">18</span>时表示黄灯，具体计数器数值表示红灯和绿灯亮度对应的字典下标</span><br><span class="line"><span class="number">20</span>~<span class="number">23</span>时表示白灯，具体计数器数值表示红灯、绿灯和蓝灯亮度对应的字典下标</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基于树莓派GPIO控制的介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>树莓派引脚介绍与GPIO的初步认识与应用</title>
    <link href="https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://values.keys.moe/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2019-03-02T01:03:20.000Z</published>
    <updated>2022-09-27T16:58:33.957Z</updated>
    
    <content type="html"><![CDATA[<p>​下图所示为树莓派3b+开发板。上方引脚处左下角引脚为1号引脚。</p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/树莓派.png" alt style="zoom:10%;"><span id="more"></span><h1><span id="一认识gpio">一．认识GPIO</span></h1><p>所谓GPIO，就是“通用输入&#x2F;输出”接口，树莓派系统中已经编译自带了GPIO的驱动。</p><p><strong>树莓派GPIO的编号方式：</strong></p><img src="/2019/03/02/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%95%E8%84%9A%E4%BB%8B%E7%BB%8D%E4%B8%8EGPIO%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E4%B8%8E%E5%BA%94%E7%94%A8/引脚.png" alt><p><strong>1.功能物理引脚（physical）：</strong><br>从左到右，从上到下。左边为奇数，右边为偶数。共计40个引脚，计数为1-40。<br><strong>2.BCM：</strong><br>编号侧重于CPU寄存器，根据BCM2835的GPIO寄存器编号。具体编号参照上图中BCM一栏。<br><strong>3.wiringPi</strong><br>编号侧重实现逻辑，把GPIO端口从0开始编号，这种编号方便编程，参考上图wPi一栏。</p><p>三种编号的方式均指代的对象相同，只是编码方式不同。</p><p><strong>其中</strong><br>GPIO.**: 通用输入输出接口，GPIO端口，可通过软件分别配置成输入或输出。<br>3.3V&#x2F;5.0V(VCC):提供3.3V&#x2F;5.0V的固定电压<br>0V（GND）：接地<br>SDA<em>：SDA 是I2C 数据传输口。<br>SCL：I2C时钟信号。<br>RXD：接收数据的引脚。<br>TXD：发送数据的引脚。<br>MOSI：为主输出从输入。<br>MISO：为主输入从输出。<br>SCLK: 系统时钟,指晶振频率。<br>CE</em>：片选（芯片有效）-表示低电平有效</p><h1><span id="二python-gpio">二．Python GPIO</span></h1><p>默认的python GPIO均已集成入raspbian系统，不需要另外安装。<br>如果需要安装，请按以下顺序：<br>1、先安装python-dev，输入以下指令。<br>      sudo apt-get install python-dev<br>2、安装RPi.GPIO，依次输入以下指令。<br>1)下载：wget <a href="http://raspberry-gpio-python.googlecode.com/files/RPi.GPIO-0.5.3a.tar.gz">http://raspberry-gpio-python.googlecode.com/files/RPi.GPIO-0.5.3a.tar.gz</a><br>2)解压缩：tar xvzf RPi.GPIO-0.5.3a.tar.gz<br>3)进入解压之后的目录： cd RPi.GPIO-0.5.3a<br>4)启动安装 ： sudo python setup.py install</p><h1><span id="三应用">三．应用</span></h1><p><strong>导入模块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import RPi.GPIO as GPIO</span><br></pre></td></tr></table></figure><p><strong>设置引脚引用模式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setmode(GPIO.BOARD)</span><br><span class="line">#or</span><br><span class="line">GPIO.setmode(GPIO.BCM)</span><br></pre></td></tr></table></figure><p><strong>检测使用的哪种模式可以使用：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mode=GPIO.getmode()</span><br><span class="line">#mode的取值有GPIO.BOARD, GPIO.BCM, None</span><br></pre></td></tr></table></figure><p>以下代码如无特殊说明，均使用GPIO.BOARD引脚映射模式。</p><p><strong>设置引脚方向（输入，输出）:</strong></p><p>如 设置40号引脚为输入方向：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pin = <span class="number">40</span></span><br><span class="line">GPIO.setup(pin,GPIO.IN)</span><br></pre></td></tr></table></figure><p>输出同理：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setup(pin,GPIO.OUT)</span><br><span class="line"><span class="comment">#输出还可以加初始电平：</span></span><br><span class="line">GPIO.setup(pin,GPIO.OUT,initial=GPIO.HIGH)</span><br><span class="line">如果要同时设置多个引脚：</span><br><span class="line"><span class="built_in">list</span>=[<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">GPIO.setup(<span class="built_in">list</span>,GPIO.OUT)</span><br></pre></td></tr></table></figure><p>如果要同时设置多个引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">GPIO.setup(<span class="built_in">list</span>,GPIO.OUT)</span><br></pre></td></tr></table></figure><p><strong>释放</strong><br>一般来说，程序到达最后都需要释放资源，这个好习惯可以避免偶然损坏树莓派。释放脚本中的使用的引脚：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.cleanup()</span><br></pre></td></tr></table></figure><p><strong>警告</strong><br>如果RPi.GRIO检测到一个引脚已经被设置成了非默认值，那么你将看到一个警告信息。你可以通过下列代码禁用警告：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setwarnings(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>注意，GPIO.cleanup()只会释放掉脚本中使用的GPIO引脚，并会清除设置的引脚编号规则。</p><p><strong>读取</strong><br>我们也常常需要读取引脚的输入状态，获取引脚输入状态如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIO.input(channel)</span><br><span class="line">#低电平返回0 / GPIO.LOW / False，高电平返回1 / GPIO.HIGH / True。</span><br></pre></td></tr></table></figure><p>如果输入引脚处于悬空状态，引脚的值将是漂动的。<br>换句话说，读取到的值是未知的，因为它并没有被连接到任何的信号上，直到按下一个按钮或开关。<br>由于干扰的影响，输入的值可能会反复的变化。<br>使用如下代码可以解决问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_UP)  </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">GPIO.setup(channel, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)</span><br><span class="line"><span class="comment">#需要注意的是，上面的读取代码只是获取当前一瞬间的引脚输入信号。</span></span><br></pre></td></tr></table></figure><p>如果需要实时监控引脚的状态变化，可以有两种办法。<br>最简单原始的方式是每隔一段时间检查输入的信号值，这种方式被称为轮询。<br>如果你的程序读取的时机错误，则很可能会丢失输入信号。<br>轮询是在循环中执行的，这种方式比较占用处理器资源。<br><strong>轮询方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while GPIO.input(channel) == GPIO.LOW:</span><br><span class="line">    time.sleep(0.01)  # wait 10 ms to give CPU chance to do other things</span><br></pre></td></tr></table></figure><p>另一种响应GPIO输入的方式是使用中断（边缘检测），这里的边缘是指信号从高到低的变换（下降沿）或从低到高的变换（上升沿）。<br><strong>边缘检测</strong><br>边缘是指信号状态的改变，从低到高（上升沿）或从高到低（下降沿）。通常情况下，我们更关心于输入状态的该边而不是输入信号的值。这种状态的该边被称为事件。</p><p>wait_for_edge() 函数<br>wait_for_edge()被用于阻止程序的继续执行，直到检测到一个边缘。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel = GPIO.wait_for_edge(channel, GPIO_RISING, timeout=<span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>add_event_detect() 函数<br>该函数对一个引脚进行监听，一旦引脚输入状态发生了改变，调用event_detected()函数会返回true，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GPIO.add_event_detect(channel, GPIO.RISING)</span><br><span class="line"><span class="keyword">if</span> GPIO.event_detected(channel):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Button pressed&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>RPI.GPIO 模块的脉宽调制（PWM）功能</strong><br>脉宽调制(PWM)是指用微处理器的数字输出来对模拟电路进行控制，是一种对模拟信号电平进行数字编码的方法。在树莓派上，可以通过对GPIO的编程来实现PWM。<br>创建一个 PWM 实例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = GPIO.PWM(channel, frequency)</span><br></pre></td></tr></table></figure><p>启用 PWM：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.start(dc)   # dc 代表占空比（范围：0.0 &lt;= dc &lt;= 100.0）</span><br></pre></td></tr></table></figure><p>更改频率：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ChangeFrequency(freq)   <span class="comment"># freq 为设置的新频率，单位为 Hz</span></span><br></pre></td></tr></table></figure><p>更改占空比：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.ChangeDutyCycle(dc)  <span class="comment"># 范围：0.0 &lt;= dc &gt;= 100.0</span></span><br></pre></td></tr></table></figure><p>停止 PWM：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.stop()</span><br><span class="line"><span class="comment">#注意，如果实例中的变量“p”超出范围，也会导致 PWM 停止。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">入门介绍</summary>
    
    
    
    <category term="树莓派" scheme="https://values.keys.moe/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
    <category term="树莓派" scheme="https://values.keys.moe/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    <category term="Python" scheme="https://values.keys.moe/tags/Python/"/>
    
  </entry>
  
</feed>
